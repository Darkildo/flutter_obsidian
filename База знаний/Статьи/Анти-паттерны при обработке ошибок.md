[Оригинальный пост](https://plugfox.dev/error-handling-and-anti-patterns/)

***Анти-паттерны при обработке ошибок в дарте.

Этим прекрасным вечером мы разберём типовые заблуждения в теме работы с ошибками, в том числе с их перехватом и обработкой, а также сразу подскажем, как действительно стоит поступать в подобных ситуациях. Стоит упомянуть, что эти заблуждения в основном связаны с практикой других языков и не учитывают специфику Dart, что и порождает столько не совсем корректных способов решения данной проблемы.

Большинство нелепых способов обработки ошибок, что мне довелось увидеть связано с потерей стека вызовов, а без него логи ошибок в релизе (например, Crashlytics или Sentry) практически бесполезны, потому и отследить корень проблем бывает очень сложно.

## Распространенные ошибки

При некой ошибки просто возвращем null.

```dart
try {
  final json = await client.get(id);
  return Item.fromJson(json);
} on Object {
  return null;
}
```

Вы **теряете саму ошибку и стек вызовов**, а значит не сможете корректно объяснить пользователю, что именно пошло не так и отправить в крашлитику стек вызовов для последующего анализа проблемы.

Использование [[unions]] для обработки и возврата ошибок(ты что дружок в джаву попал?):

```dart
try {
  final json = await client.get(id);
  final item = Item.fromJson(json);
  return DataOrException.data(item);
} catch (error) {
  return DataOrException.failure(error);
}
```

На самом деле уже лучше, чем просто возвращать **null**, но что плохого вам сделал [[stack trace]]? При таком способе обработки ошибок вы его безвозвратно потеряете, а при попытках в каждый подобный класс добавлять параметр для стека вызовов будет просто пустой тратой времени. Тем более не стоит забывать, что в dart мы имеем сепараци. самой ошибки от стека вызовов, что и делает не самым комфортным использование такого подхода.

Последний из популярных и ошибочных способов обработки ошибок - прокидывать ещё больше ошибок через ***throw***.

```dart
try {
  final json = await client.get(id);
  return Item.fromJson(json);
} on Object {
  throw ApiException();
}
```

Ну вот опять, мы теряем **стек вызовов** и нам точно также крайне тяжело понять, что же произошло в тот злополучный момент.

## Советы и решения

Не стоит боятся ошибок. Гораздо большей проблемой будет, если вы отлавливаете ошибку через **catch**, а после просто замалчиваете её.  
Хорошей манерой при подобном подходе будет избегать попыток предугадать все возможные ошибки при работе, ведь в процессе тестирования вы сами увидите через аналитику вашего приложения, в каких местах необходимы дополнительные проверки на корректность исполнения.

Просто не ловите их там, где им не место.

```dart
  final json = await client.get(id);
  return Item.fromJson(json);
```

Также вы можете повторно сгенерировать исходное исключение.

```dart
try {
  final json = await client.get(id);
  return Item.fromJson(json);
} on Object {
  rethrow;
}
```

Если вы хотите передать свою **собственную** ошибку, то не забудьте про стек вызовов. Для этого используйте [throwWithStackTrace](https://api.dart.dev/stable/2.18.2/dart-core/Error/throwWithStackTrace.html) .

```dart
try {
  final json = await client.get(id);
  return Item.fromJson(json);
} on Object catch (_, stackTrace) {
  Error.throwWithStackTrace(
    ApiException(‘Something goes wrong’),
    stackTrace,
  );
}
```

Если вы думаете, что сможете решить проблемы от конкретного исключения — попытайтесь отловить определенные типы ошибок, которые вы можете предсказать.

```dart
try {
  final json = await client.get(id);
  return Item.fromJson(json);
} on FormatException {
  return const Item.empty();
}
```

Не забывайте, что вы можете перехватывать различные типы ошибок и конструкция **try-catch-finally** поможет вам в этом.

```dart
try {
  ...
} on TimeoutException {
  ...
} on HandshakeException catch (error, stackTrace) {
  ...
  Error.throwWithStackTrace(
    ApiException(‘Something goes wrong’),
    stackTrace,
  );
} on Object {
  ...
  rethrow;
} finally {
  ...
}
```

Используйте [zones](https://api.dart.dev/stable/2.18.2/dart-async/runZonedGuarded.html) чтобы перехватывать асинхронные операции без ожидания их выполнения с конструкцией **await**.

```dart
runZonedGuarded<void>(() async {
    longAsyncOperation();
    runApp(App());
  },
  (error, stackTrace) => ...
);
```

`Future` объекты имеют метод [ignore](https://api.dart.dev/stable/2.18.2/dart-async/FutureExtensions/ignore.html) , можете его использовать, если для вас не имеет значения успех выполнения данного метода.

```dart
FirebaseAnalytics.instance.logAppOpen().ignore();
FirebaseCrashlytics.instance.recordError(exception, stackTrace).ignore();
```

**Стек вызовов спасает ваше время** во время поиска ошибок. Посмотрите ниже, как вы можете добавлять дополнительную информацию при его пробросе.

```dart
StackTrace.fromString('${StackTrace.current}\n'
    'Headers: "${jsonEncode(response.headers)}"');
```

Вы можете ознакомиться с библиотекой [stack_trace](https://pub.dev/packages/stack_trace) . Это упрощает взаимодействие с трассировкой стека и позволяет сделать его более емким и красивым.

## Послесловие

Не бойтесь глючного кода, бойтесь неподдерживаемый код с плавающими ошибками, скрытыми исключениями и потерянными трассировками стека.

Вы все равно не сможете отловить все баги на этапе разработки. Особенно если помнить, что есть дедлайны и не всегда есть отдельный дизайн для отображения ошибок. Некоторые ошибки могут воспроизводиться только на определенных устройствах, вендорах и версиях. Бьюсь об заклад, что большинство разработчиков не смогут назвать половину исключений, которые вы можете получить с помощью обычного HTTP-запроса. Просто не волнуйтесь, пусть произойдет ошибка, но зато вы будете на готове.

Ну и еще не всякая ошибка является багом, например, если вы пытаетесь отправить письмо при отсутствии интернета, это не баг, но если таких случаев много, то возможно нужно будет подумать об этом с точки зрения интерфейса или внедрить новую функцию отложенной отправки. Вы определенно захотите реализовать эту функцию, если увидите много таких случаев. И если вы не выявите эту проблему, вы не узнаете о потребностях пользователя и не сможете впоследствии улучшить пользовательский опыт.

Но так как разработчик не может предсказать все исключения и правильно их обработать, то такой разработчик просто пишет общий обработчик для всех ошибок. Не беда, это проблема с кешем, интернетом, устройством, бизнес-логикой, операционной системой, обновленным бэкендом, таймаутом, рукопожатием, отсутствием прав и т.д.
  
И поскольку вы не можете предсказать конкретную проблему, вы также не можете правильно с ней справиться. Неправильное обращение с самой проблемой становится еще большей проблемой.
  
Следовательно, это приводит к «замалчиванию» исключений и серьезному ухудшению качества работы приложения, а владельцы продукта и сам разработчик не знают о проблемах.



#PlugFox  #ОбработкаОшибок